#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_complex.h>
#include <gsl/gsl_complex_math.h>

double slit_width_mm = 2;            // silt width. measured in mm
double screen_width_mm = 0.01;           // remote screen to receive diffraction result, measured in mm
double wavelength_nm = 632;             // wavelength of light, measured in nm
double y_screen_dm = 10;                // the distance between slits and screen, measured in dm
double integrate_step = 0.000001;     // integrate step, measured in m, the smaller the preciser
double integrate_cuts_slit = 1000;      // number of cuts when integrating inside a slit, the larger, the preciser
double speed_of_light = 300000000.0;    // speed of light, measured in m/s

/* for a single point inside a slit, positioned at x_point,
 * and another point,positioned at x_screen,
 * at a specific moment of time, calculate the complex amplitude. */
gsl_complex calculateComplexAmplitudeOnePoint(double x_point, double x_screen, double time) {
    double delta_x = fabs(x_point - x_screen);
    double distance = gsl_complex_abs(gsl_complex_rect(delta_x, y_screen_dm * pow(10, -1)));
    double number_of_wavelength = distance / (wavelength_nm * pow(10, -9));
    double amplitude_angle =
            2 * M_PI * ((number_of_wavelength) + time * speed_of_light / (wavelength_nm * pow(10, -9)));
    return gsl_complex_polar(1, amplitude_angle);
}

/* for a single slit, starts at slit_position[0], ends at slit_position[1],
 * and a single point on screen, positioned at x_screen,
 * at a specific moment of time,
 * calculate the complex amplitude */
gsl_complex calculateComplexAmplitudeOneSlit(const double slit_position[], double x_screen, double time) {
    gsl_complex total_complex_amplitude = gsl_complex_rect(0, 0);
    for (double i = slit_position[0];
         i <= slit_position[1];
         i += (slit_position[1] - slit_position[0]) / integrate_cuts_slit) {
        total_complex_amplitude =
                gsl_complex_add(calculateComplexAmplitudeOnePoint(i, x_screen, time), total_complex_amplitude);
    }
    return total_complex_amplitude;
}

/* for multiple slits, start and ends at slit_position[0] slit_position[1], etc,
 * and a position x_screen on screen,
 * calculate the complex sum of all the complex amplitude generated by all slits */
gsl_complex calculateComplexAmplitudeMultiSlits(const double **slits_position, int number_of_slits,
                                                double x_screen, double time) {
    gsl_complex total_complex_amplitude = gsl_complex_rect(0, 0);

    for (int i = 0; i < number_of_slits; i++) {
        total_complex_amplitude =
                gsl_complex_add(total_complex_amplitude,
                                calculateComplexAmplitudeOneSlit(slits_position[i], x_screen, time));
    }
    return total_complex_amplitude;
}

int main() {
    clock_t begin = clock();
    printf("[Program started]\n");
    FILE *fp;
    fp = fopen("/tmp/data.dat", "w");
    /* Double slit fraunhofer diffraction */
    const double slit_position_a[2] = {-3 * slit_width_mm / 2.0 * pow(10, -3),
                                       -1 * slit_width_mm / 2.0 * pow(10, -3)};
    const double slit_position_b[2] = {1 * slit_width_mm / 2.0 * pow(10, -3),
                                       3 * slit_width_mm / 2.0 * pow(10, -3)};
    const double *slits_position[2] = {slit_position_a, slit_position_b};
    int number_of_slits = 2;

    /* Double slit fraunhofer diffraction */
/*    const double slit_position_a[2] = {-5 * slit_width_mm / 2.0 * pow(10, -3),
                                       -3 * slit_width_mm / 2.0 * pow(10, -3)};
    const double slit_position_b[2] = {3 * slit_width_mm / 2.0 * pow(10, -3),
                                       5 * slit_width_mm / 2.0 * pow(10, -3)};
    const double *slits_position[2] = {slit_position_a, slit_position_b};
    int number_of_slits = 2;*/

/* Quad slit fraunhofer diffraction */
/*    double slit_position_a[2] = {-7*slit_width_mm/2.0*pow(10,-3),
                                 -5*slit_width_mm/2.0*pow(10,-3)};
    double slit_position_b[2] = {5*slit_width_mm/2.0*pow(10,-3),
                                 7*slit_width_mm/2.0*pow(10,-3)};
    double slit_position_c[2] = {-3*slit_width_mm/2.0*pow(10,-3),
                                 -1*slit_width_mm/2.0*pow(10,-3)};
    double slit_position_d[2] = {1*slit_width_mm/2.0*pow(10,-3),
                                 3*slit_width_mm/2.0*pow(10,-3)};
    double* slits_position[4] = {slit_position_a, slit_position_b, slit_position_c, slit_position_d};
    int number_of_slits = 4;*/

    /* Single slit fraunhofer diffraction */
/*    const double slit_position_a[2] = {-slit_width_mm / 2.0 * pow(10, -3),
                                       slit_width_mm / 2.0 * pow(10, -3)};
    const double *slits_position[1] = {slit_position_a};
    int number_of_slits = 1;*/


    /* Calculate the period of light */
    double period = wavelength_nm * pow(10, -9) / speed_of_light;
    int progress = 0;
    /* Integrate on the whole screen */
    clock_t integrate_start = clock();
    clock_t integrate_end;
    for (double y = -screen_width_mm / 2.0; y < screen_width_mm / 2.0; y += integrate_step) {
        if (progress < (int) (100 * (y + screen_width_mm / 2.0) / (screen_width_mm))) {
            progress++;
            if (progress < 10) {
                printf("Current progress: 0%d%%\t", progress);
            } else {
                printf("Current progress: %d%%\t", progress);
            }
            integrate_end = clock();
            double integrate_time_spent = (double) (integrate_end - integrate_start) / CLOCKS_PER_SEC;
            printf("Estimated time left: %f s\n", (100 - progress) * integrate_time_spent);
            integrate_start = clock();
        }
        /* Integrate on a period of light */
        double light_intensity = 0;
        for (double time = 0; time < period; time += integrate_step) {
            light_intensity += gsl_pow_int(
                    GSL_REAL(calculateComplexAmplitudeMultiSlits(
                            (const double **) slits_position, number_of_slits, y, time)), 2);
        }
        fprintf(fp, "%f\t%f\n", y, light_intensity / (period / integrate_step));
    }
    fclose(fp);
    clock_t end = clock();
    double time_spent = (double) (end - begin) / CLOCKS_PER_SEC;
    printf("Data processing complete, time elapsed: %f s\n", time_spent);
    printf("Plotting...\n");
    double draw_x = wavelength_nm * pow(10, -9) /
            (slit_width_mm * pow(10, -3)) * y_screen_dm * pow(10, -1);
    char *plot_cmd = malloc(sizeof(char) * 1024);
    sprintf(plot_cmd, "gnuplot -e \"set arrow from %f, graph 0 to %f, graph 1 nohead lc rgb 'red' ;"
                      "set arrow from -%f, graph 0 to -%f, graph 1 nohead lc rgb 'red' ;"
                      "plot '/tmp/data.dat' using 1:2 ps 0.01 with lines notitle\" -p &> /dev/null",
                      draw_x, draw_x, draw_x, draw_x);
    printf("lambda/d*l=%f\n",
           wavelength_nm * pow(10, -9) / (slit_width_mm * pow(10, -3)) * y_screen_dm * pow(10, -1));
    printf("Running gnuplot command: %s\n", plot_cmd);
//    setenv("DISPLAY", "172.29.32.1:0", 1);
    system(plot_cmd);
    printf("Press any key to continue...\n");
    getchar();
    return 0;
}




/* Double slit fraunhofer diffraction */
/*const double slit_position_a[2] = {-5 * slit_width_mm / 2.0 * pow(10, -3), -3 * slit_width_mm / 2.0 * pow(10, -3)};
const double slit_position_b[2] = {3 * slit_width_mm / 2.0 * pow(10, -3), 5 * slit_width_mm / 2.0 * pow(10, -3)};
const double *slits_position[2] = {slit_position_a, slit_position_b};
int number_of_slits = 2;*/


